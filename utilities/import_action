#!/usr/bin/env ruby

require 'json'
require 'readwise'
require 'time'
require 'uri'

class Jekyll
  def self.import_book(book)
    return unless book.should_import?

    File.open("_posts/#{book.formatted_date}-#{book.book_id}.md", 'w') do |f|
      f.write book.post_text
    end
  end

  def self.import_book_highlights(book)
    book.highlights.each do |highlight|
      import_highlight(highlight, book)
    end
  end

  def self.import_highlight(highlight, book)
    return unless highlight.should_import?(book)

    File.open("_posts/#{highlight.formatted_date}-#{highlight.highlight_id}.md", 'w') do |f|
      f.write highlight.post_text(book)
    end
  end
end

module ReadwiseExtras
  module Book
    def has_image?
      cover_image_name && download_image
    end

    def download_image
      return false unless cover_image_name
      return true if File.exist?(cover_image_name)

      system "curl '#{cover_image_url}' -o #{cover_image_name}"
    end

    def cleanup_image
      return true unless has_image?

      system "rm #{cover_image_name}"
    end

    def cover_image_name
      return if cover_image_url.nil?

      extension = URI.parse(cover_image_url).path.split('/').last.match(/\.[a-z|A-Z]*$/)&.to_a&.first || '.jpg'
      book_id + extension
    end

    def post_text
      [
        "---",
        "title: \"#{stripped_title}\"",
        "tags: #{formatted_tags}",
        "canonical: #{source_url}",
        "author: #{author_stripped}",
        "book: #{book_id}",
        "book_title: \"#{stripped_title}\"",
        "book_asin: #{asin}",
        "hide_title: true",
        "readwise_url: #{readwise_url}",
        "cover_image_url: #{cover_image_url}",
        "favicon_url: #{favicon_url}",
        "source_emoji: #{source_emoji}",
        "source_url: \"#{outbound_url(text_fragment: title)}\"",
        "---",
        "### Margin Notes",
        "",
        note,
      ].compact.join("\n")
    end

    def formatted_tags
      base_tags = tags.map { |t| t['name'] }
      base_tags.concat(["#{category}-#{book_id}"])
        .concat(highlights.map { |h| h.tags.map { |ht| ht['name'] } })
        .flatten.uniq.join(' ')
    end

    def formatted_date
      highlighted_at_time.to_date.to_s
    end

    def stripped_title
      @stripped_title ||= readable_title.gsub('"', "'")
    end

    def should_import?
      return true if note&.length&.positive?

      false
    end

    def citation_html
      "<cite>#{image_html}#{author_html}<span class=\"bar\"> | </span>#{title_html}</cite>"
    end

    def source_md(text_fragment: nil)
      "<em>#{title_html(text_fragment: text_fragment)}</em>"
    end

    def title_html(text_fragment: nil)
      if navigable_url?
        "<a href=\"#{outbound_url(text_fragment: text_fragment)}\" class=\"u-url\" target=\"_blank\">#{title}</a>"
      else
        "<span class=\"non-url\">#{title}</span>"
      end
    end

    def navigable_url?
      return true if source_url && !source_url.match?(/^mailto:/)

      false
    end

    # Ref: https://developer.mozilla.org/en-US/docs/Web/Text_fragments
    def outbound_url(text_fragment: nil)
      return source_url unless text_fragment

      text_start = text_fragment.split("\n").first.split("[").first.split(" ").first(10).join(" ").strip
      "#{source_url}#:~:text=#{URI::Parser.new.escape(text_start)}"
    end

    def author_stripped
      author.to_s.split("\n").reject { |a| a.empty? }.join(" ")
    end

    def author_html
      "<span class=\"p-author h-card\">#{author_stripped}</span>"
    end

    def image_html
      if favicon_url
        "<img alt=\"favicon\" src=\"#{favicon_url}\" class=\"source-favicon\"/>"
      else
        "<span class=\"source-emoji\">#{source_emoji}</span>"
      end
    end

    def author_md
      [author_stripped, image_md].join(' ')
    end

    def image_md
      if favicon_url
        "![favicon](#{favicon_url}){:class=\"source-favicon\"}"
      else
        source_emoji
      end
    end

    def source_emoji
      if source_url&.match?(/^mailto:/)
        "‚úâÔ∏è"
      elsif category == 'books' || category == 'supplementals'
        "üìï"
      else
        "üåê"
      end
    end

    def favicon_url
      return nil unless source_url&.match?(/^https{0,1}:\/\//)

      hostname = URI.parse(source_url).hostname
      return nil unless hostname

      "https://s2.googleusercontent.com/s2/favicons?domain=#{hostname}"
    end
  end

  module Highlight
    def post_text(book)
      [
        "---",
        "title: \"#{title}\"",
        "tags: #{formatted_tags(book)}",
        "canonical: #{book.source_url}",
        "author: #{book.author_stripped}",
        "book: #{book.book_id}",
        "book_title: \"#{book.stripped_title}\"",
        "book_asin: #{book.asin}",
        "hide_title: true",
        "readwise_url: #{readwise_url}",
        "cover_image_url: #{book.cover_image_url}",
        "favicon_url: #{book.favicon_url}",
        "source_emoji: #{book.source_emoji}",
        "source_url: \"#{book.navigable_url? ? book.outbound_url(text_fragment: title) : ""}\"",
        "toc: #{note.nil? || note.empty? ? 'false' : 'true'}",
        "---",
        "",
        formatted_text,
      ].compact.join("\n")
    end

    def title
      @title ||= text.split(' ').first(25).join(' ').gsub(/\]\(\S*\)/, "]").gsub('"', "'") + '...'
    end

    def citation_html(book)
      "<cite>#{book.image_html}#{book.author_html}<span class=\"bar\"> | </span>#{book.title_html(text_fragment: title)}</cite>"
    end

    def formatted_tags(book)
      base_tags = tags.map { |t| t['name'] }
      base_tags << 'inbox' if base_tags.empty?
      base_tags.concat(["#{book.category}-#{book.book_id}"])
        .flatten.join(' ')
    end

    def formatted_text
      pieces = [text]
      unless note.nil? || note.empty?
        pieces << ""
        pieces << "### Margin Notes"
        pieces << note
      end

      pieces.join("\n")
    end

    def formatted_date
      Time.parse(highlighted_at || updated_at).to_date.to_s
    end

    def should_import?(book)
      return false if book.category == "supplementals" && tags.empty?
      return false if tags.map { |t| t['name'] }.include?("discard")

      true
    end
  end
end
Readwise::Book.include(ReadwiseExtras::Book)
Readwise::Highlight.include(ReadwiseExtras::Highlight)


# Steps:
# - Wipe out old _posts
# - Import highlights into _posts
# - Copy over _manual_posts into _posts
class Importer
  def self.import
    clean_posts
    client = Readwise::Client.new(token: ENV['READWISE_TOKEN'])
    limit = ENV['READWISE_LIMIT']&.to_i
    books = client.export(updated_after: Time.parse("2000-01-01").iso8601)
    books = books.sample(limit) if limit
    books.each do |book|
      Jekyll.import_book(book)
      Jekyll.import_book_highlights(book)
    end
    copy_manual_posts
  rescue => e
    puts "Import Failed: #{e.message}"
  end

  def self.clean_posts
    system 'rm _posts/*.md'
  end

  def self.copy_manual_posts
    system 'cp _manual_posts/*.md _posts/'
  end
end

Importer.import
