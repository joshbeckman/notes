#!/usr/bin/env ruby
# frozen_string_literal: true

require 'jekyll'
require 'json'
require 'net/http'
require 'time'
require_relative 'models/post'
require_relative 'models/asset'

module PESOS
  class JekyllFilter
    include Jekyll::Filters
    attr_accessor :site, :context

    def initialize(opts = {})
      @site = Jekyll::Site.new(Jekyll.configuration(opts))
      @context = Liquid::Context.new(@site.site_payload, {}, site: @site)
    end
  end

  class Mastodon
    class Error < StandardError; end

    attr_reader :site

    def initialize
      @site = Jekyll::Site.new(Jekyll.configuration({}))
      @site.read
    end

    def import_replies
      replies = outbox.dig('orderedItems').filter do |item|
        item.dig('object', 'inReplyTo')
      end
      replies.each { |reply| import_reply(reply) }
    end

    def import_posts
      posts = outbox.dig('orderedItems').filter do |item|
        next false if item.dig('object', 'inReplyTo')
        next false if post_exists?(item['object']['url'])

        true
      end
      posts.each { |post| import_post(post) }
    end

    def post_exists?(url)
      @site.posts.docs.any? do |post|
        post.data['mastodon_social_status_url'] == url
      end
    end

    def import_reply(reply)
      title = reply['object']['summary'] || "Reply to #{find_mention_handle(reply['object']['tag'])}"
      image = find_image(reply['object']['attachment'])
      post = Post.new(
        body: reply['object']['content'],
        category: 'replies',
        date: Time.parse(reply['published']),
        in_reply_to: reply['object']['inReplyTo'],
        hide_title: true,
        mastodon_social_status_url: reply['object']['url'],
        canonical: reply['object']['url'],
        image: image,
        slug: reply['object']['id'].split('/').last,
        tags: ['mastodon'],
        title: title
      )
      post.create_file
    end

    def import_post(post)
      title = post['object']['summary'] || "Post to #{find_mention_handle(post['object']['tag'])}"
      image = find_image(post['object']['attachment'])
      bluesky_status_url = false if find_mention_handle(post['object']['tag']).nil?
      post = Post.new(
        body: post['object']['content'],
        category: 'blog',
        date: Time.parse(post['published']),
        hide_title: true,
        mastodon_social_status_url: post['object']['url'],
        bluesky_status_url: bluesky_status_url,
        canonical: post['object']['url'],
        image: image,
        slug: reply['object']['id'].split('/').last,
        tags: ['mastodon'],
        title: title
      )
      post.create_file
    end

    def find_mention_handle(tags)
      return 'Mastodon' if tags.nil?

      mention = tags.find { |tag| tag['type'] == 'Mention' }
      return 'Mastodon' if mention.nil?

      mention['name']
    end

    def find_image(attachments)
      return nil if attachments.nil?

      image = attachments.find { |attachment| attachment['mediaType']&.include?('image') }
      return nil if image.nil?

      asset = Asset.new(url: image['url'], category: 'images')
      asset.download
      asset.public_path
    end

    def outbox
      uri = URI.parse('https://mastodon.social/users/joshbeckman/outbox?page=true')
      req = Net::HTTP::Get.new(uri)
      req['Accept'] = 'application/activity+json'
      req['Content-Type'] = 'application/json'
      res = Net::HTTP.start(uri.hostname, uri.port, use_ssl: true) do |http|
        http.request(req)
      end

      raise Error, 'Outbox request failed' unless res.is_a?(Net::HTTPSuccess)

      JSON.parse(res.body)
    end
  end
end

mastodon = PESOS::Mastodon.new
mastodon.import_replies
mastodon.import_posts
